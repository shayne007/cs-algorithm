排序（上）：为什么插入排序比冒泡排序更受欢迎？

项目中，我们经常会用到排序。掌握下面这3种时间复杂度为 O(n²) 的经典排序算法的分析方法，我们就能高效、简单地实现小规模数据排序问题。

1.如何分析一个“排序算法”？

- 排序算法的执行效率
- 排序算法的内存消耗
- 排序算法的稳定性(如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变)

2.冒泡排序的原理和性能分析

​	”冒泡“的方式依次**比较、交换**，不断找出剩余元素的最大值（或最小值）

​	原地排序;稳定排序

​	O(n^2)时间复杂度(有序度/逆序度方式估算交换次数方法)

3.插入排序的原理和性能分析

​	未排序区间元素与已排序区间元素的**比较、移动**

​	**插入排序中的移动与冒泡排序的交换相比，有更少的操作**

4.选择排序的原理和性能分析

​	从未排序区间中选择最小值，交换至已排序区间末尾

​	



排序（下）：如何用快排思想在O(n)内查找第K大元素？

归并排序和快速排序是时间复杂度为 O(nlogn) 的排序算法，掌握它们的原理和性能分析，就能实现大规模数据排序问题。

1.归并排序的原理和性能分析

​	从中间分为两部分，递归排序

​	O(nlogn)时间，O(n)空间，稳定、非原地排序

2.快速排序的原理和性能分析

​	以pivot（分区点），排序递归

​	O(nlogn)时间，O(1)空间，不稳定，原地排序



线性排序：如何根据年龄给100万用户数据排序？

桶排序、计数排序、基数排序是时间复杂度为 O(n) 的线性排序算法，掌握它们的适用场景，我们就能有针对性地解决特殊数据排序问题，提高效率。

1.桶排序的原理和适用场景
2.计数排序的原理和适用场景
3.基数排序的原理和适用场景



排序优化：如何实现一个通用的、高性能的排序函数？

大部分排序函数都是采用 O(nlogn) 排序算法来实现，掌握这3个方面，就能实现一个工业级的通用的、高效的排序函数

1.如何选择合适的排序算法
2.如何用优化快速排序
3.分析qsort() 函数的底层实现原理







思考题

1.我们讲过，特定算法是依赖特定的数据结构的。我们今天讲的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢?



2.如何使用哨兵简化归并排序算法

3.现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？