### 散列表

1.如何理解散列思想？

​	key --> hash function -->  table(array)

2.有哪些散列函数？如何设计散列函数？

​	MD5、SHA、CRC等哈希算法； 取模运算

- 散列函数的设计不能太复杂
- 散列函数生成的值要尽可能随机并且均匀分布

数据分析法

3.散列冲突的解决方法是什么？

 - 开放寻址法

   ​	线性探测、二次探测、双重散列

   ​	动态扩容、减小装载因子（以空间消耗为代价），**散列表的装载因子=填入表中的元素个数/散列表的长度**

   ​	装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。

   ​	均摊扩容

-  链表法

  当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。

5.工业级散列表怎么应用？

​	java.util.HashMap

- 默认初始大小16，事先知道数据量时，设置相应的值可减少动态扩容的次数:

  ```java
  static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
  ```

- 最大装载因子0.75，元素个数超过0.75*capacity时两倍动态扩容

  ```java
  static final float DEFAULT_LOAD_FACTOR = 0.75f;
  ```

- 链表长度超度8时，链表转为红黑树

  ```java
  static final int TREEIFY_THRESHOLD = 8;	
  ```

- 哈希函数

  ```java
   static final int hash(Object key) {
       int h;
       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   }
  ```



散列表（下）：为什么散列表和链表经常会一起使用？

弄懂这三个例子，你就能掌握散列表和链表的结合方式，实现快速顺序遍历散列表中的数据，提高工作效率。

1.案例一：LRU 缓存淘汰算法

​	散列表+双向链表	![img](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

2.案例二：Redis 有序集合

​	跳表+散列表

3.案例三：Java LinkedHashMap

​	LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。



思考题

1.假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

2.有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

3.在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？

4.今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？

5.假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：

- 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
- 查找积分在某个区间的猎头 ID 列表；
- 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表